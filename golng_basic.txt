- VS Code 터미널에서 실행할 때
  .go파일이 있는 경로에 들어간 다음 "go run main.go"명령어를 실행한다. (여기서, main.go는 파일명이다)

- 프로그램은 main패키지에서 실행을 시작한다.

- fmt 패키지
	- fmt.Sprint() : 값을 문자열로 만든다.
	- fmt.Printf() : 문자열에서 형식을 지정하여 문자열을 출력한다.
- math 패키지
	- math.Sqrt() : 제곱근
	- math.Pow() : 지수 함수 ( ex) 2의 3승 )
- math/rand 패키지
	- rand.Intn : 같은 숫자를 반환함. ex) Intn(10) → 0<=n<100 사이의 랜덤 int형 n을 반환
- runtime 패키지
	- runtime.GOOS : 운영체제를 확인할 때 사용한다.
- time 패키지
	- time.Now() : 리턴타입(time.Time) / 현재시각
	- time.Now().Hour() : 리턴타입(int)  
	- time.Now().Weekday() : 리턴타입(time.Weekday) 
			      : ex) 오늘이 월요일이면, 출력값은 Monday가 나온다.
	- time.요일 : 리턴타입(time.Weekday) 
		   : ex) time.Saturday
	- time.Tick() : 일정한 간격으로 무언가를 반복하고자 할 때 사용할 수 있다.
		   : 미래의 한 시점에 무언가를 하고싶을때 사용할 수 있다.
		   : 값을 전송하는 채널을 사용
	- time.After() : x초의 타임아웃 후에 전달되는 값을 대기한다.
		    : 값을 전송하는 채널을 사용
`	- time.Second : 1s를 의미함
- string 패키지
	- strings.NewReader(s string) : s를 읽어서 새 Reader를 반환한다. (리턴값: *strings.Reader)

- 대문자로 시작하는 이름이 export됨

- func 함수명(매개변수) 반환형
  ex) func add(x int, y int) int
	→ 변수 이름 뒤에 type이 온다. ex) x int
	→ 'x int, y int'를 'x, y int'로 줄일 수 있다.
	→ 반환값에 이름이 정해질 수 있다. 긴 코드에서는 가독성을 떨어뜨린다. 
		→ naked return문: 인자가 없는 return문은 이름이 주어진 반환값을 반환함

- var문은 package나 함수 단에 존재할 수 있다. (단, := 구문은 함수 밖에서 사용할 수 없다)
- 상수 : const키워드와 함께 선언. ( := 구문을 통해 선언될 수 없다)
  ex) const Pi = 3.14

- Zero values 
  bool의 기본값은 false
  int의 기본값은 0
  string의 기본값은 ""(빈 문자열)
  pointers의 기본값은 nil
  slices의 기본값은 nil
  maps의 기본값은 nil
  interfaces의 기본값은 nil

- 초깃값이 존재한다면, type은 생략 가능
  type이 정해지지 않은 숫자 상수가 올 때, int/float64/complex128이 된다.
  ex) v := 42 (int)
      v := 42.1234 (float64)
      v := 42.1234i (complex128)

- T(v) : v라는 값을 T type으로 변환해준다.
- Go는 다른 type의 요소들 간의 할당에는 명시적인 변환이 필요하다. (하지 않으면, 오류발생)
  ex) var i int = 42			[ i := 42 ]
      var f float64 = float64(i)		[ f := float64(i) ]

- for문의 세 가지 구성 요소(초기화, 조건, 증감문)를 감싸는 괄호가 없고, {}괄호가 항상 필수
  ex) for i := 0; i < 10; i++ {}
- 초기화 구문과 사후 구문은 필수가 아님
  ex) for; sum<1000; {}
- Go의 While문 ( ;을 생략한다 )
  ex) for sum < 1000{}
- 무한루프 (반복조건을 생략한다)
  ex) for{}

- if문 : {}괄호 항상 필수
  ex) if x<0 {}
- if문도 조건문 전에 수행될 짧은 구문으로 시작할 수 있다.
  ex) if v := math.Pow(x,n); v<lim{}
      => v는 if문 안에서만 사용할 수 있다.

- switch문 (다른 언어와의 차이점)
  - 자동으로 break가 제공된다
  - switch case는 상수일 필요가 없으며, 그 값들은 정수일 필요도 없다.
  - 조건이 없는 Switch는 switch true와 동일하다
    ex) switch {} (= switch true{})

- defer문 : 자신을 둘러싼 함수가 종료할 때까지 실행 연기
  ex) defer fmt.Println("world")
       fmt.Print("hello ")
       결과값 : hello world
  - defer문으로 연기된 함수 호출들은 스택에 쌓인다. 한 함수가 종료될 때 후입선출 순서로 실행된다.

- Pointers(포인터)
  - *T타입은 T값을 가리키는 포인터
    ex) var p *int
  - & 연산자 : 피연산자에 대한 포인터 생성
    ex) i := 42
        p = &i
  - * 연산자: 포인터가 가리키는 주소의 값
    ex) *p = 21 //포인터 p를 통해 i 설정
- C언어와는 다르게, Go는 포인터 산술을 지원하지 않는다.

- Structs(구조체) : 필드의 집합체
  ex) type Vertex struct{
	X int
	Y int
      }
- 구조체의 필드 접근 : .(dot)
- ex) &Vertex{1,2} : 구조체 값으로 포인터를 반환한다.
                       : 타입은 *main.Vertex 

- Slices(슬라이스) : 배열의 요소들을 동적인 크기로 유연하게 볼 수 있다.
  - []T타입은 T타입을 원소로 가지는 슬라이스
    ex) var a []int //슬라이스 변수 선언 : 배열을 선언하듯이 하지만, 크기는 지정하지 않는다.
- 'a := names[0:2]'처럼 names의 배열을 참조하는 슬라이스가 있다.
  'a[0] = "min"'으로 바꾸면 names의 해당 요소도 수정이 된다. 마찬가지로 names배열의 값을 변경하게 되면, 슬라이스도 수정이 된다. 
  => 기본 배열의 한 영역을 나타내기 때문에
- 아래 슬라이스 표현식들은 동일한 의미 
  a[0:10]
  a[:10]
  a[0:]
  a[:]
- 슬라이스는 배열처럼 쭉 있는게 아니라 포인터로 연결되어 있다.
- 슬라이스의 길이(_length) : 슬라이스가 포함하는 요소의 개수	[len(슬라이스)로 얻을 수 있음]
  슬라이스의 용량(_capcity) : 슬라이스의 첫 번째 요소부터 계산하는 기본 배열의 요소의 개수	[cap(슬라이스)로 얻을 수 있음]
		         : 뒤에 얼마나 덧붙일 공간이 있느냐에 따라서 용량이 결정된다.
- 뒤에 공간이 있으면 그 공간을 살릴 수도 있다
- nil 슬라이스의 길이와 용량은 0이며, 기본 배열을 가지고 있지 않다.
- make함수로 0으로 이루어진 동적 크기의 배열을 생성할 수 있다.
  ex) a := make([]int, 5) //길이 5, 용량 5
      a := make([]int, 0, 5) //길이 0, 용량 5 

- range: 슬라이스 또는 맵의 요소들을 순회한다.
           두 개의 값이 반환되는데, 첫번째는 인덱스이고, 두번째는 해당 인덱스의 값의 복사본이다.
           ex) for i, v := range pow{} // pow슬라이스를 순회한다.
- for i, _ := range pow{} 또는 for i := range pow : 인덱스만 원할 때에는, _을 할당하거나 두번째 변수를 생략한다.
  for _, value := range pow : value만 원할때, 첫번째 변수에 _를 할당하여 건너뛴다.

- map은 키를 값에 매핑한다.
- nil map은 키도 없고, 키를 추가할 수도 없다.
- make()은 사용 준비가 된 맵을 반환한다.
- 맵 리터럴은 구조체 리터럴과 같지만, 키가 필요하다. 
  최상위 타입이 타입 이르일 경우, 리터럴의 요소에서 생략 가능
  ex) var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":   {37.42202, -122.08408},
       }
- 키가 존재하는지
  ex) v, ok := m["Answer"] //키가 존재하는지 : v는 key인 "Answer"의 value고, ok는 "Answer"가 있는지 없는지
							         map안에 있다면 ok는 true, 아니면 false

- 클로저란 내부함수가 외부함수의 지역변수에 접근 할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미한다.

- 메서드 : receiver인자가 있는 함수
           : func키워드와 메서드 이름 사이에 있다.
            ex) func (v Vertex) Abs() float64{}
           : 구조체 뿐만 아니라 다른 형식에 대해서도 메서드를 선언할 수 있다.
             ex) type MyFloat float64
- 메소드와 동일한 패키지에 type이 정의된 receiver가 있는 메소드만 선언할 수 있다. type이 다른 패키지에 정의된 receiver로 메소드를 선언할 수 없다.

- 포인터 리시버가 있는 메소드는 리시버가 가리키는 값을 수정할 수 있다.
  포인터 리시버가 값 리시버보다 일반적이다.
  값 리시버를 사용하면 복사를 해서 사용하기 때문에 값이 수정이 되지 않는다.
- 포인터 리시버를 사용하는 이유
  : 메서드가 리시버가 가리키는 값을 수정할 수 있기 때문에
  : 각각의 메서드 call에서의 value 복사 문제를 파하기 위해서

- Interfaces : _interface_type_은 "메소드"의 시그니처 집합으로 정의된다.
               : 인터페이스 유형의 값은 해당 메소드를 구현하는 모든 값을 보유할 수 있다.
- 인터페이스의 메서드가 실행될 때 인터페이스를 구현한다. (명시적 선언도, 키워드도 없다)
- 인터페이스 타입의 변수는 한 쌍의 정보(튜플)를 저장한다. 하나는 인터페이스를 구현하는 기본 데이터 값이고, 다른 하나는 그 데이터의 모든 타입 정보를 담고 있다.
- Note that an interface value that holds a nil concrete value is itself non-nil.(nil 콘크리트 값을 갖는 인터페이스 값 자체가 nil이 아니라는 점에 유의해야 합니다.)
- nil 인터페이스에서 메소드를 호출하면 런타임 에러가 발생한다.
  => 어떠한 메소드를 호출할지를 나타내는 인터페이스 튜플 내부의 타입이 없기 때문이다.
  ex) type I interface { M() }
       func main() {
	var i I 	 //nil 인터페이스
	describe(i) 
	i.M() //런타임 에러
       }	
       func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
       }
- _empty_interface : 0메서드를 지칭하는 인터페이스
	           : 모든 유형의 값을 가질 수 있다.(모든 유형은 최소 0개의 메소드를 가진다)
	           : 알 수 없는 값을 처리하는데 이용된다.
- _type_assertion_ : 인터페이스 값에 대한 접근을 제공
                       ex) t := i.(T)
		  => 인터페이스 값 i가 타입 T를 갖고 있으면, 그 타입에 대한 값을 변수 t에 할당하고 있다고 선언한다.
		       만약, i가 T를 가지고 있지 않으면 그 선언은 panic상태가 된다.
- _type_switch : 여러 타입의 선언을 직렬로 허용하는 구조
	      : 값이 아닌 타입을 명시한다. 그 값들은 지정된 인터페이스 값에 의해 유지되는 값의 타입과 비교된다.
	      : 타입 선언 i.(T)와 같은 구문을 가지게 되는데, 특정 타입인 T는 type이라는 키워드로 대체된다.
	      ex) switch v := i.(type){
		case int:
		case string:
		default:  //디폴트 케이스(일치하지 않는 경우)에서 변수v는 인터페이스 종류와 값이 i와 같다.
	          }

- Stringers : 가장 널리 사용되는 인터페이스
	 : fmt패키지에 의해 정의되었다.
	 : Stringer는 자신을 문자열로 설명할 수 있는 타입 => 값을 출력하기 위해 사용
	 : type Stringer interface{
		String() string
	   }
	 : ex) func (p Person) String() string { // String() 메소드를 구현하여 Stringer인터페이스를 충족시켰다.
		return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
	       }

- Error : 함수는 종종 error값을 반환하며, 호출 코드는 오류가 nil과 같은지 테스트하여 오류를 처리해야합니다. 
         : Go는 보통 함수나 메서드의 대부분 마지막 반환 값으로 error 상태를 반환한다. ex) func Open(name string) (file *File, err error)
           에러가 발생하지 않으면 nil을 반환하고, 에러가 발생하면 에러 상황에 맞는 error값을 반환한다.
         : type error interface{
	Error() string
           }

- io.Reader 인터페이스 : 데이터 스트림의 읽기를 나타낸다.
- Read메소드
  func (T) Read(b []byte) (n int, err error)
  : 주어진 바이트 조각으로 데이터를 채우고 채워진 바이트 수와 오류 값을 반환한다
  : 스트림이 종료되면 io.EOF 오류를 반환한다.

- Goroutines : Go 런타임에 의해 관리되는 경량 쓰레드
	    : 함수를 호출할 때 앞에 'go'라는 키워드를 붙여서 호출하면, 호출하는 함수와 현재 실행하고 있는 함수의 흐름이 구분되어 별개로 동작한다
	      => 'go' 키워드를 붙여서 호출한 함수는 "동시성"을 가진다고 할 수 있다.
	      => main 함수는 고루틴이 종료되든 말든 신경쓰지 않고 본인 할 일이 끝나면 종료한다.
	          → sleep하수를 이용하여 고루틴으로 호출되는 함수의 실행이 끝나기 전에 main함수가 종료되는 것을 막는다.
	    : goroutine은 같은 주소의 공간에서 실행되고, 따라서 공유된 메모리는 synchronous(동기적)해야한다.

- Channel : 채널 연산자인 <-을 통해 데이터를 주고 받는 통로 역할을 하는 자료구조
	  ex) ch <- v    // 채널 ch에 v를 전송한다.
	       v := <-ch  // ch로 부터 값을 받고, 값을 v에 대입한다.
	: 기본 자료형을 제공하여 다른 패키지나 라이브러리 없이 바로 사용할 수 있다.
	: 데이터는 화살표의 방향대로 흐른다.
	: 채널을 사용하기 전에 make함수를 통해 미리 생성해야한다.
	  ex) chan int : chan이라는 키워드와 함께 해당 채널에서 주고 받을 자료형을 정의한다.
	  ex) ch := make(chan int)
- 기본적으로 전송과 수신은 다른 한 쪽이 준비될 때까지 block상태
  → 명시적인 lock이나 조건 변수 없이 gorountine이 synchronous하게 작업될 수 있도록 한다.

- Buffered Channels : Channel이 버퍼를 가질 수 있다는 의미
		: make함수 두 번째 인자로 buffer 길이를 제공
		  ex) ch := make(chan int, 100)
		: buffered channel로의 전송은 그 buffer의 사이즈가 꽉 찼을 때에만 block이 된다.
		  buffer로부터의 수신은 그 buffer가 비어있을 때 block이 된다.
		  ex) ch := make(chan int, 1)
  		       ch <- 1
		       ch <- 2  //오류 발생

- channel close : 전송자는 더 이상 보낼 데이터가 없다는 것을 암시하기 위해 channel close를 한다.
	       : 수신자가 더 이상 들어오는 값이 없다는 것을 알아야하는 경우에만 필요하다.
	       : 수진자가 채널이 닫혔는지 테스트하는 방법
	         v, ok := <-ch   // 더 수신할 값이 없고, channel이 닫혀있다면 ok는 false
	         for i := range c {} // chnnel이 닫힐 때까지 반복해서 channel에서 값을 수신한다.
	       : 수신자가 아닌 전송자만이 channel을 닫아야 한다.
	         닫힌 channel에 전송하는 것은 panic을 야기할 것이다.

- select : select문은 goroutine이 다중 커뮤니케이션 연산에서 대기할 수 있게 한다.
          : select는 case문들 중 하나가 실행될 때까지 block된다.
          : 만약 다수의 case가 준비되는 경우에는 select가 무작위로 하나를 선택한다.
          : default case는 다른 case들이 모두 준비되지 않았을 때 실행된다.

- sync.Mutex : mutual exclusion라고 불린다. 자료구조에서는 mutex라고 불린다.
	    : "충돌을 피하기 위해" 오직 "하나의 goroutine만"이 어떤 순간에 어떤 변수에 접근할 수 있도록 하고싶을 때 사용한다.
	    :  Go의 표준 라이브러리는 sync.Mutex와 두가지 method를 통해 mutual exclusion을 제공
	       ( Lock, Unlock )
	    : 코드 블럭을 Lock과 Unlock으로 감쌈으로써 mutual exclusion 속에서 수행될 코드 블럭을 정의할 수 있다.
	    : unlock을 하지않으면 오류가 발생한다.
	    : unlocked될 것이라는 것을 확실히 하기 위해 defer을 사용할 수 있다.
	      ex) defer mu.Unlock()




























