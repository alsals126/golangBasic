- 프로그램은 main패키지에서 실행을 시작한다.

- fmt 패키지
	- fmt.Sprint() : 값을 문자열로 만든다.
	- fmt.Printf() : 문자열에서 형식을 지정하여 문자열을 출력한다.
- math 패키지
	- math.Sqrt() : 제곱근
	- math.Pow() : 지수 함수 ( ex) 2의 3승 )
- math/rand 패키지
	- rand.Intn : 같은 숫자를 반환함. ex) Intn(10) → 0<=n<100 사이의 랜덤 int형 n을 반환
- runtime 패키지
	- runtime.GOOS : 운영체제를 확인할 때 사용한다.
- time 패키지
	- time.Now() : 리턴타입(time.Time) / 현재시각
	- time.Now().Hour() : 리턴타입(int)  
	- time.Now().Weekday() : 리턴타입(time.Weekday) 
			      : ex) 오늘이 월요일이면, 출력값은 Monday가 나온다.
	- time.요일 : 리턴타입(time.Weekday) 
		   : ex) time.Saturday

- 대문자로 시작하는 이름이 export됨

- func 함수명(매개변수) 반환형
  ex) func add(x int, y int) int
	→ 변수 이름 뒤에 type이 온다. ex) x int
	→ 'x int, y int'를 'x, y int'로 줄일 수 있다.
	→ 반환값에 이름이 정해질 수 있다. 긴 코드에서는 가독성을 떨어뜨린다. 
		→ naked return문: 인자가 없는 return문은 이름이 주어진 반환값을 반환함

- var문은 package나 함수 단에 존재할 수 있다. (단, := 구문은 함수 밖에서 사용할 수 없다)
- 상수 : const키워드와 함께 선언. ( := 구문을 통해 선언될 수 없다)
  ex) const Pi = 3.14

- Zero values 
  bool의 기본값은 false
  int의 기본값은 0
  string의 기본값은 ""(빈 문자열)
  pointers의 기본값은 nil
  slices의 기본값은 nil
  maps의 기본값은 nil
  interfaces의 기본값은 nil

- 초깃값이 존재한다면, type은 생략 가능
  type이 정해지지 않은 숫자 상수가 올 때, int/float64/complex128이 된다.
  ex) v := 42 (int)
      v := 42.1234 (float64)
      v := 42.1234i (complex128)

- T(v) : v라는 값을 T type으로 변환해준다.
- Go는 다른 type의 요소들 간의 할당에는 명시적인 변환이 필요하다. (하지 않으면, 오류발생)
  ex) var i int = 42			[ i := 42 ]
      var f float64 = float64(i)		[ f := float64(i) ]

- for문의 세 가지 구성 요소(초기화, 조건, 증감문)를 감싸는 괄호가 없고, {}괄호가 항상 필수
  ex) for i := 0; i < 10; i++ {}
- 초기화 구문과 사후 구문은 필수가 아님
  ex) for; sum<1000; {}
- Go의 While문 ( ;을 생략한다 )
  ex) for sum < 1000{}
- 무한루프 (반복조건을 생략한다)
  ex) for{}

- if문 : {}괄호 항상 필수
  ex) if x<0 {}
- if문도 조건문 전에 수행될 짧은 구문으로 시작할 수 있다.
  ex) if v := math.Pow(x,n); v<lim{}
      => v는 if문 안에서만 사용할 수 있다.

- switch문 (다른 언어와의 차이점)
  - 자동으로 break가 제공된다
  - switch case는 상수일 필요가 없으며, 그 값들은 정수일 필요도 없다.
  - 조건이 없는 Switch는 switch true와 동일하다
    ex) switch {} (= switch true{})

- defer문 : 자신을 둘러싼 함수가 종료할 때까지 실행 연기
  ex) defer fmt.Println("world")
       fmt.Print("hello ")
       결과값 : hello world
  - defer문으로 연기된 함수 호출들은 스택에 쌓인다. 한 함수가 종료될 때 후입선출 순서로 실행된다.

- Pointers(포인터)
  - *T타입은 T값을 가리키는 포인터
    ex) var p *int
  - & 연산자 : 피연산자에 대한 포인터 생성
    ex) i := 42
        p = &i
  - * 연산자: 포인터가 가리키는 주소의 값
    ex) *p = 21 //포인터 p를 통해 i 설정
- C언어와는 다르게, Go는 포인터 산술을 지원하지 않는다.

- Structs(구조체) : 필드의 집합체
  ex) type Vertex struct{
	X int
	Y int
      }
- 구조체의 필드 접근 : .(dot)
- ex) &Vertex{1,2} : 구조체 값으로 포인터를 반환한다.
                       : 타입은 *main.Vertex 

- Slices(슬라이스) : 배열의 요소들을 동적인 크기로 유연하게 볼 수 있다.
  - []T타입은 T타입을 원소로 가지는 슬라이스
    ex) var a []int //슬라이스 변수 선언 : 배열을 선언하듯이 하지만, 크기는 지정하지 않는다.
- 'a := names[0:2]'처럼 names의 배열을 참조하는 슬라이스가 있다.
  'a[0] = "min"'으로 바꾸면 names의 해당 요소도 수정이 된다. 마찬가지로 names배열의 값을 변경하게 되면, 슬라이스도 수정이 된다. 
  => 기본 배열의 한 영역을 나타내기 때문에
- 아래 슬라이스 표현식들은 동일한 의미 
  a[0:10]
  a[:10]
  a[0:]
  a[:]
- 슬라이스는 배열처럼 쭉 있는게 아니라 포인터로 연결되어 있다.
- 슬라이스의 길이(_length) : 슬라이스가 포함하는 요소의 개수	[len(슬라이스)로 얻을 수 있음]
  슬라이스의 용량(_capcity) : 슬라이스의 첫 번째 요소부터 계산하는 기본 배열의 요소의 개수	[cap(슬라이스)로 얻을 수 있음]
		         : 뒤에 얼마나 덧붙일 공간이 있느냐에 따라서 용량이 결정된다.
- 뒤에 공간이 있으면 그 공간을 살릴 수도 있다
- nil 슬라이스의 길이와 용량은 0이며, 기본 배열을 가지고 있지 않다.
- make함수로 0으로 이루어진 동적 크기의 배열을 생성할 수 있다.
  ex) a := make([]int, 5) //길이 5, 용량 5
      a := make([]int, 0, 5) //길이 0, 용량 5 

- range: 슬라이스 또는 맵의 요소들을 순회한다.
           두 개의 값이 반환되는데, 첫번째는 인덱스이고, 두번째는 해당 인덱스의 값의 복사본이다.
           ex) for i, v := range pow{} // pow슬라이스를 순회한다.
- for i, _ := range pow{} 또는 for i := range pow : 인덱스만 원할 때에는, _을 할당하거나 두번째 변수를 생략한다.
  for _, value := range pow : value만 원할때, 첫번째 변수에 _를 할당하여 건너뛴다.

- map은 키를 값에 매핑한다.
- nil map은 키도 없고, 키를 추가할 수도 없다.
- make()은 사용 준비가 된 맵을 반환한다.
- 맵 리터럴은 구조체 리터럴과 같지만, 키가 필요하다. 
  최상위 타입이 타입 이르일 경우, 리터럴의 요소에서 생략 가능
  ex) var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":   {37.42202, -122.08408},
       }
- 키가 존재하는지
  ex) v, ok := m["Answer"] //키가 존재하는지 : v는 key인 "Answer"의 value고, ok는 "Answer"가 있는지 없는지
							         map안에 있다면 ok는 true, 아니면 false

- 클로저란 내부함수가 외부함수의 지역변수에 접근 할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미한다.

- 메서드 : receiver인자가 있는 함수
           : func키워드와 메서드 이름 사이에 있다.
            ex) func (v Vertex) Abs() float64{}
           : 구조체 뿐만 아니라 다른 형식에 대해서도 메서드를 선언할 수 있다.
             ex) type MyFloat float64
- 메소드와 동일한 패키지에 type이 정의된 receiver가 있는 메소드만 선언할 수 있다. type이 다른 패키지에 정의된 receiver로 메소드를 선언할 수 없다.

- 포인터 리시버가 있는 메소드는 리시버가 가리키는 값을 수정할 수 있다.
  포인터 리시버가 값 리시버보다 일반적이다.
  값 리시버를 사용하면 복사를 해서 사용하기 때문에 값이 수정이 되지 않는다.
- 포인터 리시버를 사용하는 이유
  : 메서드가 리시버가 가리키는 값을 수정할 수 있기 때문에
  : 각각의 메서드 call에서의 value 복사 문제를 파하기 위해서

- Interfaces : _interface_type_은 "메소드"의 시그니처 집합으로 정의된다.
               : 인터페이스 유형의 값은 해당 메소드를 구현하는 모든 값을 보유할 수 있다.
- 인터페이스의 메서드가 실행될 때 인터페이스를 구현한다. (명시적 선언도, 키워드도 없다)
- 인터페이스 타입의 변수는 한 쌍의 정보(튜플)를 저장한다. 하나는 인터페이스를 구현하는 기본 데이터 값이고, 다른 하나는 그 데이터의 모든 타입 정보를 담고 있다.
- Note that an interface value that holds a nil concrete value is itself non-nil.(nil 콘크리트 값을 갖는 인터페이스 값 자체가 nil이 아니라는 점에 유의해야 합니다.)
- nil 인터페이스에서 메소드를 호출하면 런타임 에러가 발생한다.
  => 어떠한 메소드를 호출할지를 나타내는 인터페이스 튜플 내부의 타입이 없기 때문이다.
  ex) type I interface { M() }
       func main() {
	var i I 	 //nil 인터페이스
	describe(i) 
	i.M() //런타임 에러
       }	
       func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
       }
- _empty_interface : 0메서드를 지칭하는 인터페이스
	           : 모든 유형의 값을 가질 수 있다.(모든 유형은 최소 0개의 메소드를 가진다)
	           : 알 수 없는 값을 처리하는데 이용된다.
- _type_assertion_ : 인터페이스 값에 대한 접근을 제공
                       ex) t := i.(T)
		  => 인터페이스 값 i가 타입 T를 갖고 있으면, 그 타입에 대한 값을 변수 t에 할당하고 있다고 선언한다.
		       만약, i가 T를 가지고 있지 않으면 그 선언은 panic상태가 된다.
- _type_switch : 여러 타입의 선언을 직렬로 허용하는 구조
	      : 값이 아닌 타입을 명시한다. 그 값들은 지정된 인터페이스 값에 의해 유지되는 값의 타입과 비교된다.
	      : 타입 선언 i.(T)와 같은 구문을 가지게 되는데, 특정 타입인 T는 type이라는 키워드로 대체된다.
	      ex) switch v := i.(type){
		case int:
		case string:
		default:  //디폴트 케이스(일치하지 않는 경우)에서 변수v는 인터페이스 종류와 값이 i와 같습니다.
	          }

